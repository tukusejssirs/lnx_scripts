# $HOME/.bashrc: executed by bash(1) for non-login shells.
# See /usr/share/doc/bash/examples/startup-files (in the package bash-doc)

# Format definition
# Note: not every terminal emulator supports all of them
bold="\e[1m"  # This is either bold (if supported) or bright in colour
dim="\e[2m"
italics="\e[3m"
underline="\e[4m"
blink="\e[5m"
overline="\e[6m"
invert="\e[7m"  # Invert the foreground and background colours
hide="\e[8m"  # Change foreground to background colour
strike="\e[9m"  # Strikethrough

# Format and colour reseting
unbold="\e[21m"
undim="\e[22m"
unitalics="\e[23m"
ununderline="\e[24m"
unblink="\e[25m"
unoverline="\e26m"
uninvert="\e[27m"
unhide="\e[28m"
unstrike="\e[9m"
normal="\e[0"  # Normal format (i.e reset all manually set format)
fdefault="\e[39m"  # Default foreground colour
bdefault="\e[49m"  # Default background colour

# Foreground colours (8/16)
black="\e[30m"
red="\e[31m"
green="\e[32m"
yellow="\e[33m"
blue="\e[34m"
magenta="\e[35m"
cyan="\e[36m"
lgrey="\e[37m"
dgrey="\e[90m"
lred="\e[91m"
lgreen="\e[92m"
lyellow="\e[93m"
lblue="\e[94m"
lmagenta="\e[95m"
lcyan="\e[96m"
white="\e[97m"

# Background colours (8/16)
bblack="\e[40m"
bred="\e[41m"
bgreen="\e[42m"
byellow="\e[43m"
bblue="\e[44m"
bmagenta="\e[45m"
bcyan="\e[46m"
blgrey="\e[47m"
bdgrey="\e[100m"
blred="\e[101m"
blgreen="\e[102m"
blyellow="\e[103m"
blblue="\e[104m"
blmagenta="\e[105m"
blcyan="\e[106m"
bwhite="\e[107m"

# Check where we are running the shell (Android/Termux, Linux)
# Then set some system-dependant variables
if [[ `uname -o` == "Android" ]]; then
	if [[ `echo $SHELL` == "/data/data/com.termux/files/usr/bin/login" ]]; then
		# We are in Android/Termux
		usr="/data/data/com.termux/files/usr"
		etc="/data/data/com.termux/files/usr/etc"
		bin="/data/data/com.termux/files/usr/bin"
		var="/data/data/com.termux/files/usr/var"
		date=`which date`

		# To make `su` work, add `/su/bin/` to $PATH
		PATH=/su/bin:/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin/applets
	fi
elif [[ `uname -o` == "GNU/Linux"  ]]; then
	usr="/usr"
	etc="/etc"
	bin="/bin"
	var="/var"
	date="$bin/date"
fi

# PS1
function return_value(){
	retval=$?
	if [[ $retval -ne 0 ]]; then
		echo -e "${lred}$retval${fdefault}"
	else
		echo -e "${lgreen}$retval${fdefault}"
	fi
}

function remote_host(){
	if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
		echo -e "${lred}@${fdefault}"
	else
		echo "@"
	fi
}
# Set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi
t_date=`$date +"%l.%m%P"` PS1="\n[${lmagenta}$t_date${fdefault}]\`return_value\` ${debian_chroot:+($debian_chroot)}\u`remote_host`\h: \[\e]0;\w\a\n\\$ "

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return ;;
esac

# Don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options.
HISTCONTROL=ignoreboth
# Append to the history file, don't overwrite it
shopt -s histappend
# For setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=999900000
HISTFILESIZE=999000
# Check the window size after each command and, if necessary, update the values of LINES and COLUMNS.
shopt -s checkwinsize
# If set, the pattern "**" used in a pathname expansion context will match all files and zero or more directories and subdirectories.
shopt -s globstar
# Make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"
# Set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color)
	color_prompt=yes ;;
esac

# Uncomment for a coloured prompt, if the terminal has the capability; turned off by default to not distract the user: the focus in a terminal window should be on the output of commands, not on the prompt
#force_color_prompt=yes
#if [ -n #"$force_color_prompt" ]; then
#    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have colour support; assume it's compliant with Ecma-48 (ISO/IEC-6429). (Lack of such support is extremely rare, and such a case would tend to support 
#setf rather than setaf.)
#	color_prompt=yes
#    else
#	color_prompt=
#    fi
#fi
#unset color_prompt force_color_prompt

# If this is an xterm, set the title to user@host: dir
#case "$TERM" in
#	xterm*|rxvt*) ;;
#	*) ;;
#esac

# Coloured GCC warnings and errors
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# Source functions, aliases and programs
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
if [ -d ~/.bash_functions ]; then
    . ~/.bash_functions/*
fi
if [ -f ~/.bash_progs ]; then
    . ~/.bash_progs
fi

# Enable programmable completion features (you don't need to enable this, if it's already enabled in $etc/bash.bashrc and $etc/profile; sources $etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f $usr/share/bash-completion/bash_completion ]; then
    . $usr/share/bash-completion/bash_completion
  elif [ -f $etc/bash_completion ]; then
    . $etc/bash_completion
  fi
fi

#if [[ `uname -o` == "Android" 
#]]; then
#	# Update romcal repo
#	echo "Do you want update 
#romcal?"
#	read ans
#	if [[ $ans == "y" ]]; then
#		p=$PWD
#		cd 
#$HOME/.scripts/romcal
#		git fetch && git pull 
#origin && git pull
#		cd $p
#	fi fi
# ~/.bashrc: executed by bash(1) for 
#non-login shells.
# see 
#/usr/share/doc/bash/examples/startup-files 
#(in the package bash-doc)
# for examples Format definition
# Note: not every terminal emulator 
#supports all of them bold="\e[1m" # 
#This is either bold (if supported) or 
#bright in colour dim="\e[2m" 
#italics="\e[3m" underline="\e[4m" 
#blink="\e[5m" overline="\e[6m" 
#invert="\e[7m" # Invert the foreground 
#and background colours hide="\e[8m" # 
#Change forrground to background colour 
#strike="\e[9m" # Strikethrough
# Format and colour reseting
#unbold="\e[21m" undim="\e[22m" 
#unitalics="\e[23m" 
#ununderline="\e[24m" unblink="\e[25m" 
#unoverline="\e26m" uninvert="\e[27m" 
#unhide="\e[28m" unstrike="\e[9m" 
#normal="\e[0" # Normal format (i.e 
#reset all manually set format) 
#fdefault="\e[39m" # Default foreground 
#colour bdefault="\e[49m" # Default 
#background colour
# Foreground colours (8/16)
#black="\e[30m" red="\e[31m" 
#green="\e[32m" yellow="\e[33m" 
#blue="\e[34m" magenta="\e[35m" 
#cyan="\e[36m" lgrey="\e[37m" 
#dgrey="\e[90m" lred="\e[91m" 
#lgreen="\e[92m" lyellow="\e[93m" 
#lblue="\e[94m" lmagenta="\e[95m" 
#lcyan="\e[96m" white="\e[97m"
# Background colours (8/16)
#bblack="\e[40m" bred="\e[41m" 
#bgreen="\e[42m" byellow="\e[43m" 
#bblue="\e[44m" bmagenta="\e[45m" 
#bcyan="\e[46m" blgrey="\e[47m" 
#bdgrey="\e[100m" blred="\e[101m" 
#blgreen="\e[102m" blyellow="\e[103m" 
#blblue="\e[104m" blmagenta="\e[105m" 
#blcyan="\e[106m" bwhite="\e[107m"
# Check where we are running the shell 
#(Android/Termux, Linux)
# Then set some system-dependant 
#variables if [[ `echo $SHELL` == 
#"/data/data/com.termux/files/usr/bin/login" 
#]]; then
#	# We are in Android/Termux
#	
#usr="/data/data/com.termux/files/usr"
#	
#etc="/data/data/com.termux/files/usr/etc"
#	
#bin="/data/data/com.termux/files/usr/bin"
#	
#var="/data/data/com.termux/files/usr/var"
#	date="$bin/applets/date"
#	
#	# To make `su` work, add 
#`/su/bin/` to $PATH
#	
#PATH=/su/bin:/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin/applets 
#else # TODO: check it on Linux
#	usr="/usr"
#	etc="/etc"
#	bin="/bin"
#	var="/var"
#	date="$bin/date" fi
# Add ssh keys
#eval `ssh-agent -s` &>/dev/null 
#keys=`ls ~/.ssh | grep \.pub | sed 
#'s/\.pub//g' - | tr '\n' ',' | sed 
#'s/,$//' -` if [[ `echo $keys | grep 
#","` -ne "" ]]; then
#	keys=`echo $keys | sed 
#'s/^\(.*\)$/$HOME\/.ssh\/\{\1\}/' -` 
#else
#	keys="$HOME/.ssh/$keys" fi 
#ssh-add -q $keys
# PS1
#function return_value(){
#	retval=$?
#	if [[ $retval -ne 0 ]]; then
#		echo -e 
#"${lred}$retval${fdefault}"
#	else
#		echo -e 
#"${lgreen}$retval${fdefault}"
#	fi
#}
#function remote_host(){
#	if [ -n "$SSH_CLIENT" ] || [ 
#-n "$SSH_TTY" ]; then
#		echo -e 
#"${lred}@${fdefault}"
#	else
#		echo "@"
#	fi
#}
# Set variable identifying the chroot 
#you work in (used in the prompt below) 
#if [ -z "${debian_chroot:-}" ] && [ -r 
#/etc/debian_chroot ]; then
#    debian_chroot=$(cat 
#/etc/debian_chroot) fi t_date=`$date 
#+"%l.%m%P"` 
#PS1="\n[${lmagenta}$t_date${fdefault}]\`return_value\` 
#${debian_chroot:+($debian_chroot)}\u`remote_host`\h: 
#\[\e]0;\w\a\n\\$ "
# If not running interactively, don't 
#do anything case $- in
#    *i*) ;;
#      *) return;; esac
# don't put duplicate lines or lines 
#starting with space in the history.
# See bash(1) for more options
#HISTCONTROL=ignoreboth
# append to the history file, don't 
#overwrite it shopt -s histappend
# for setting history length see 
#HISTSIZE and HISTFILESIZE in bash(1) 
#HISTSIZE=1000 HISTFILESIZE=2000
# check the window size after each 
#command and, if necessary,
# update the values of LINES and 
#COLUMNS. shopt -s checkwinsize
# If set, the pattern "**" used in a 
#pathname expansion context will
# match all files and zero or more 
#directories and subdirectories.
#shopt -s globstar
# make less more friendly for non-text 
#input files, see lesspipe(1) [ -x 
#/usr/bin/lesspipe ] && eval 
#"$(SHELL=/bin/sh lesspipe)"
# set a fancy prompt (non-color, 
#unless we know we "want" color) case 
#"$TERM" in
#    xterm-color|*-256color)
#    color_prompt=yes;; esac
# uncomment for a colored prompt, if 
#the terminal has the capability; 
#turned
# off by default to not distract the 
#user: the focus in a terminal window
# should be on the output of commands, 
#not on the prompt
#force_color_prompt=yes
#if [ -n "$force_color_prompt" ]; then
#    if [ -x /usr/bin/tput ] && tput 
#setaf 1 >&/dev/null; then
#	# We have color support; 
#assume it's compliant with Ecma-48
#	# (ISO/IEC-6429). (Lack of 
#such support is extremely rare, and 
#such
#	# a case would tend to support 
#setf rather than setaf.)
#	color_prompt=yes
#    else
#	color_prompt=
#    fi fi unset color_prompt 
#force_color_prompt
# If this is an xterm set the title to 
#user@host:dir case "$TERM" in 
#xterm*|rxvt*)
#    
#    ;; *)
#    ;; esac
# enable color support of ls and also 
#add handy aliases if [ -x 
#/usr/bin/dircolors ]; then
#    test -r ~/.dircolors && eval 
#"$(dircolors -b ~/.dircolors)" || eval 
#"$(dircolors -b)"
#    alias ls='ls --color=auto'
#    #alias dir='dir --color=auto' 
#    #alias vdir='vdir --color=auto'
#    alias grep='grep --color=auto'
#    alias fgrep='fgrep --color=auto'
#    alias egrep='egrep --color=auto' 
#fi
# colored GCC warnings and errors
#export 
#GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'
# some more ls aliases
#alias ll='ls -alF' alias la='ls -A' 
#alias l='ls -CF' alias src="source 
#$HOME/.bashrc" alias trensk="trans 
#en:sk"
#alias trsken="trans sk:en"
# Add an "alert" alias for long 
#running commands.  Use like so:
#   sleep 10; alert
#alias alert='notify-send --urgency=low 
#-i "$([ $? = 0 ] && echo terminal || 
#echo error)" "$(history|tail -n1|sed 
#-e 
#'\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
# Alias definitions.
# You may want to put all your 
#additions into a separate file like
# ~/.bash_aliases, instead of adding 
#them here directly.
# See /usr/share/doc/bash-doc/examples 
#in the bash-doc package. if [ -f 
#~/.bash_aliases ]; then
#    . ~/.bash_aliases fi if [ -d 
#~/.bash_functions ]; then
#    . ~/.bash_functions/* fi if [ -f 
#~/.bash_progs ]; then
#    . ~/.bash_progs fi
# enable programmable completion 
#features (you don't need to enable
# this, if it's already enabled in 
#/etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
#if ! shopt -oq posix; then
#  if [ -f 
#/usr/share/bash-completion/bash_completion 
#]; then
#    . 
#/usr/share/bash-completion/bash_completion
#  elif [ -f /etc/bash_completion ]; 
#then
#    . /etc/bash_completion
#  fi fi if [[ `uname -o` == "Android" 
#]]; then
#	# Update romcal repo
#	echo "Do you want update 
#romcal?"
#	read ans
#	if [[ $ans == "y" ]]; then
#		p=$PWD
#		cd 
#$HOME/.scripts/romcal
#		git fetch && git pull 
#origin && git pull
#		cd $p
#	fi
#fi
#ons.
# You may want to put all your 
#additions into a separate file like
# ~/.bash_aliases, instead of adding 
#them here directly.
# See /usr/share/doc/bash-doc/examples 
#in the bash-doc package. if [ -f 
#~/.bash_aliases ]; then
#    . ~/.bash_aliases fi if [ -d 
#~/.bash_functions ]; then
#    . ~/.bash_functions/* fi if [ -f 
#~/.bash_progs ]; then
#    . ~/.bash_progs fi
# enable programmable completion 
#features (you don't need to enable
# this, if it's already enabled in 
#/etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
#if ! sh

